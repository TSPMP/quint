# Language basics

Quint mostly resembles a functional programming language, but it has a few key differences that are highlighted on this page.
- No recursion
- Prime operator (`'`)
- Modes (`pure def`, `pure val`, `def`, `val`, `nondet`, `action`, `temporal`, `run`)

The high-level reasons for this and any other differences are two:
- Quint is used to define state machines and properties, not regular executable code
- Quint uses the same logic as TLA+ and can be translated into SMT-constraints by Apalache, which is a very powerful thing and we have to constrain the language in some ways to enable it.

## No recursion

Quint doesn't support recursive operators, mutually recursive operators, nor recursive type definitions. Formal verification and recursion have complicated interactions, and on the context of Quint and the available tools, all recursion that it could, in theory, support, is the type of recursion that can be written using folds (a.k.a. reduces). 

<!-- If you try to write any sort of recursion, Quint will ask you to use folds instead. If it's impossible to rewrite it using folds, most likely it will be impossible or really hard to formally verify. -->

<!-- TODO: Write page on how to rewrite recursion into folds and link it here -->

## Prime operator

Quint uses the prime operator (`'`) to define transitions of the state machine. It can be read as "in the next state", that is, `x'` is "x in the next state" and `x' = x + 1` is "x in the next state is equal to x (in the present state) plus one".

Although in theory (and in TLA+) you could apply the prime operator to any expression, in Quint it has to always come in the format `<var>' = <expr>` which is called assignment. This prevents us from writing things that are really hard to grasp and potentially not possible to compute with the available tools.

Quint's tooling is equipped to report several different errors if you use `'` in forbidden ways. It won't let you assign a value to a variable more than once in the same transition, or forget to update a variable in some branches of transitions.

This assignments are not done as in an imperative language. They are, in fact, only defining a set of state transitions. Consider the example:
```quint
all {
  x' = 1,
  y' = x,
}
```

This could be read as "x in the next state is equal to 1 and y in the next state is equal to x in the **current** state". Someone used to imperative programming assignments will likely expect `y` to be `1` in the next state, but this is not the case here.
