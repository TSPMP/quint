---
title: "Message Soup: the Secret Sauce for Consensus Specifications"
date: 2025-07-30
excerpt: 
authors:
    - name: Yassine Boukhari
    - name: Josef Widder
    - name: Gabriela Moreira
tags:
    - intermediate
---

# Message Soup: the Secret Sauce for Consensus Specifications

If you've ever tried to debug a consensus implementation, you know the frustration: your algorithm is stuck, but the logs shows hundreds of message-passing steps that obscure what's actually happening. You're drowning in implementation details when what you really need to understand is whether enough validators have voted to move to the next phase.


Writing specifications is an art. You want to be detailed enough to actually capture all the things you want to talk about, but you want to be abstract enough to not be required to deal (too much) with the things you don't want to talk about. 



There are some best practices that are useful to know. In this post we talk about one of them, the message soup, and how it helps you to focus on the core of consensus mechanism. We'll explore the message soup pattern, demonstrate its benefits through a comparison of specification approaches, and show how it leads to more analyzable consensus specifications.


## Recent consensus specifications

Consensus algorithms have recently gained novel attention, with Malachite, Alpenglow, Espresso, and MonadBFT, minimmit being just some example projects. 
TODO link to other blog posts on Espresso, Alpenglow. 
As mentioned previously, we are working on a library to make specification of consensus algorithms more easy. As part of this, we have written specifications for newly announced algorithms. Two examples are Solana's Aplenglow and Category Lab's MonadBFT.
We basically translated what was written in these paper into Quint. 


TODO: Doings is better than reading 


As we discussed in the previous post [Alpenglow], a big value we get out of specs is that they help us to understand the algorithm. So let's do this exercise again, and let Quint generate an example , where a block has been finalized

TODO: Show that the Monad trace is long and Alpenglow is short

While we would say, that these consensus algorithms are more or less comparable, the specifications seem to differ significantly in terms of usability and efficiency. The reason is that the Alpenglow specification uses actions that are guarded by predicates over the message soup, while the Monad spec is doing explicit bookkeeping. Wait! What does all that mean?

## The message soup design pattern vs. explicit bookkeeping


Let's look a bit at the structure of the actions. As we already have seen in the previous post, in the Alpenglow specification we have actions like `blockNotarizedAction(v, slot)`, which is enabled when 60% of the voting power have sent a notar vote. In more detail, all messages that are sent are stored (forever) in a variable `msgBuffer`. This is the famous message soup. And actions are enabled when the message soup contains enough messages of a certain kind (btw. it is also good practice to model Byzantine faults, but just preloading all messages that they can send in the message soup.)

In contrast the Monad spec has the action `receive_message`. Most of the time, this action doesn't make anything interesting: it just stores that it has received a message. Only when the number of received messages surpasses a given threshold, the action does something interesting, like sending a message or finalizing a block. In contrast, the `blockNotarizedAction(v, slot)` always does something interesting, but it happens less often. 

Observe that `blockNotarizedAction(v, slot)` is guarded by a predicate over the message soup (has 60% of the voting power voted), and this predicate is evaluated by the quint simulator. This means that all the bookkeeping that an implementation is doing (reading messages one-by-one, storing it, eliminating duplicates, pruning etc.) is abstracted away, and only the effect of the bookkeeping is visible in a Quint run. This is a good thing, if we don't care too much about the bookkeeping, or if the bookkeeping just consists of storing received messages, e.g., in a set. For consensus algorithms, this typically is the case.

Note: There are specific questions, e.g., when you want to focus on optimization in the bookkeeping implementation or want to focus on specifics in which order predicates should be evaluated, where modeling bookkeeping makes a lot of sense. But for  analyzing the consensus algorithm it is good practice that these specifics should be abstracted. 

Now, `receive_message` actually pulls all the bookkeeping within the specification, and its state space. So we have a level detail here in the specification, that we don't really care about, and which actually gets in our way, when wanting to analyze the specification.

Let's be clear. This is not about comparing the two consensus algorithms. The point we are discussing here is a matter of abstraction in the specification. To not compare apples and oranges in the remainder of the post, and to not give the wrong impression that we compare different algorithms, we have refactored MonadBFT to also work on the message soup

## Performance comparison


TODO: you can take a look here. Here is the action that corresponds to the logic discussed above

TODO: look for the same witness. Show that MonadSoup finds a shorter trace


- How fast are we finding witnesses 
- How long are witnesses
    - More understandable
- How resilient to Byzantine messages

TODO: Perhaps graphs for multiple witnesses and use webpage magic to make it easier to view

TODO: Not sure where to put this:
- [Alpenglow](https://quint-lang.org/posts/alpenglow)
- [Espresso](https://informal.systems/blog/espresso-hotshot-epoch-changes-in-quint-2025)
